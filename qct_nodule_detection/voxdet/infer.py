# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_retina_infer.ipynb.

# %% auto 0
__all__ = ['subset_cfg_for_infer', 'load_model', 'RetinaInfer']

# %% ../nbs/04_retina_infer.ipynb 2
import torch
from torchvision.transforms import Compose 
from .networks.monai_retina3d import retina_detector
from munch import munchify
from .bbox_func.nms import monai_nms
import numpy as np

# %% ../nbs/04_retina_infer.ipynb 4
def subset_cfg_for_infer(cfg):
    """required transforms for spatial size"""
    required = ["anchor_params", "resolution", "classes", "spatial_size", "roi_size", "infer_cfg", \
                "infer_thr", "fe", "test_transforms", "fpn_params", "model_cfg"]
    cfg2 = {k:v for k, v in cfg.items() if k in required}
    return cfg2

# %% ../nbs/04_retina_infer.ipynb 5
def load_model(path, map_device=torch.device("cpu")):
    data = torch.load(path, map_location=map_device)
    cfg = data["cfg"]
    cfg = munchify(cfg)

    transforms = Compose([i for i in cfg.test_transforms])
    model = retina_detector(cfg)
    model.load_state_dict(data["state_dict"], strict=False)
    model = model.eval()
    return model, cfg, transforms

# %% ../nbs/04_retina_infer.ipynb 8
class RetinaInfer:
    def __init__(self, checkpoint_path: str, device: str= None , inf_safe: bool =False):
        self.model, self.cfg, self.transforms = load_model(path = checkpoint_path)
        if device is None:
            self.device = "cuda" if torch.cuda.is_available() else "cpu"
        else:
            self.device = device
        self.model.to(self.device)
        self.inf_safe = inf_safe
    
    @torch.no_grad()
    def __call__(self, img: dict, nms_thr=0.2, cnf_thr=0.05):
        if not self.inf_safe : 
            nimg = self.transforms(img)
        else :
            nimg = img
        
        if len(nimg["images"].shape) == 4:
            input_image = torch.from_numpy(nimg["images"]).type(torch.float32).to(self.device).unsqueeze(0)
        else:
            input_image = torch.from_numpy(nimg["images"]).type(torch.float32).to(self.device).unsqueeze(0).unsqueeze(0)

        logits = self.model(input_image, None, use_inferer=True)[0]  # hardcoded for one class
        if nms_thr is not None: logits = monai_nms(logits, nms_thr, cnf_thr)
        nimg.update(logits)
        if self.inf_safe :
            return nimg
        nimg = self.reverse_apply(nimg)
        return nimg
    
    def reverse_apply(self, img):
        out = img.copy()
        for tfsm in self.transforms.transforms[::-1]:
            #import pdb; pdb.set_trace()
            out = tfsm.reverse_apply(out)
        return out
