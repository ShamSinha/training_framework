# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/tfsm/07_random_erase.ipynb.

# %% auto 0
__all__ = ['get_patches', 'masked_patches_dim', 'random_erase_3d', 'RandomErase']

# %% ../../nbs/tfsm/07_random_erase.ipynb 2
import numpy as np 
import fastcore.all as fc
from ..bbox_func.bbox_iou import calculate_iou
from .standard import BaseT

# %% ../../nbs/tfsm/07_random_erase.ipynb 12
def get_patches(ims, patch_size):
    #ims is img_size, patch_size is tuple with same dimension as ims
    patches_per_dim = ims//np.asarray(patch_size)
    indices = np.indices(patches_per_dim).reshape(3, -1).T
    patches = np.concatenate((indices*patch_size, (indices+1)*patch_size), axis=1)
    return patches

# %% ../../nbs/tfsm/07_random_erase.ipynb 21
def masked_patches_dim(patches, bbox=None, mask_perc=0.2, use_bbox=False):
    if use_bbox: 
        if bbox is None: raise ValueError("bbox cannot be None when u want to use bbox")
        ious = calculate_iou(patches, bbox)
        patches = patches[np.where(~ious.any(axis=1))[0]]
    masked_patches = np.random.randint(patches.shape[0], size=int(mask_perc*patches.shape[0]))
    return patches[masked_patches]

# %% ../../nbs/tfsm/07_random_erase.ipynb 32
def _bbox3d_f2in(bbox):
    # convert a 3d bounding from float to int
    bbox[:, :3] = np.floor(bbox[:, :3])
    bbox[:, 3:] = np.ceil(bbox[:, 3:])
    bbox = bbox.astype(np.int32)
    return bbox

# %% ../../nbs/tfsm/07_random_erase.ipynb 34
def random_erase_3d(imgb, ps, bbox=None, mask_perc=0.2, mask_type="beta"):
    # imgb is zyx/nzyx ps is zyx bbox is zyxzyx mask_type can be "beta", "zeros", "ones"
    if mask_type not in ["beta", "zeros", "ones"]: raise ValueError(f"mask type {mask_type} not one of beta, zeros ones")
    ims = imgb.shape if len(imgb.shape) == 3 else imgb.shape[1:]
    bbox = _bbox3d_f2in(bbox.copy())
    if len(ims) != len(ps): raise ValueError(f"image shape and ps size should be same. got ims={ims}, ps={ps}")
    patches = get_patches(ims, ps)
    patches = masked_patches_dim(patches, bbox, mask_perc, use_bbox=True if bbox is not None else False)
    mask_val = 0 if mask_type == "zeros" else 1 
    for patch in patches:
        z1, y1, x1, z2, y2, x2 = patch
        imgb[..., z1:z2, y1:y2, x1:x2] = np.random.beta(5, 2, size=ps) if mask_type=="beta" else mask_val
    return imgb

# %% ../../nbs/tfsm/07_random_erase.ipynb 41
class RandomErase(BaseT):
    def __init__(self, patch_size=(8, 16, 16), use_bbox:bool=False, mask_perc=0.2, mask_filler: str="beta", p:float=0.2):
        """crop_size is [zyx]"""
        super().__init__()
        fc.store_attr()
    __repr__ = fc.basic_repr(flds="patch_size, use_bbox, mask_perc, mask_filler, p")
    
    def apply(self, img: dict):
        assert "images" in img.keys()
        fimg = img["images"].copy()
        boxes = img["boxes"].copy()
        
        if isinstance(fimg , np.ndarray) :
            fimg = [fimg]
            boxes = [boxes]
                        
        for i in range(len(fimg)) :
            if np.random.random() <= self.p:
                b = boxes[i] if self.use_bbox else None
                fimg[i] = random_erase_3d(fimg[i], self.patch_size, bbox=b, \
                                                mask_perc=self.mask_perc, mask_type=self.mask_filler)
        
        if len(fimg) == 1 :
            img["images"] = fimg[0]
        else :
            img["images"] = fimg
                    
        return img
