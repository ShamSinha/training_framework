# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/metrics/01_det_metrics.ipynb.

# %% auto 0
__all__ = ['assign_tp_fp_fn_linear_assignment', 'DetMetrics']

# %% ../../nbs/metrics/01_det_metrics.ipynb 2
import torch 
import fastcore.all as fc
import numpy as np
from scipy.optimize import linear_sum_assignment
from typing import Tuple , List
import torchmetrics

from ..bbox_func.bbox_iou import calculate_iou

# %% ../../nbs/metrics/01_det_metrics.ipynb 4
def assign_tp_fp_fn_linear_assignment(pred_bbox: np.ndarray, gt_bbox: np.ndarray, iou_thr: float = 0.1):
    """
    :param pred_bbox: predicted bounding boxes
    :param gt_bbox: ground truth bounding boxes
    :param iou_thr: iou threshold used to define true positive
    :return: tp, fp, fn numpy ndarray of true positives, false positives, false negatives respectively

    This function assigns true positives (tp), false positives (fp), and false negatives (fn) to the ground truth and predicted bounding boxes. It uses Hungarian algorithm to find the matching between gt_boxes and pred_boxes based on the iou (intersection over union) score. For each matching, if the iou score is greater than the threshold, it assigns 1 to the tp array of that index and 0 to the fp and fn array of that index. If there is no match or iou is less than threshold it assigns 1 to the fp and fn array of that index.
    """
    # both gt_boxes and pred_boxes are empty, there should be no tp, fp, or fn
    if len(gt_bbox) == 0 and len(pred_bbox) == 0:
        return np.zeros(0), np.zeros(0), np.zeros(0), np.zeros(0)
    # gt_boxes is empty, all predicted bounding boxes should be considered as fp
    if len(gt_bbox) == 0:
        return np.zeros(len(pred_bbox)), np.ones(len(pred_bbox)), np.zeros(0), np.zeros(0)
    # pred_boxes is empty, all ground truth bounding boxes should be considered as fn
    if len(pred_bbox) == 0:
        return np.zeros(0), np.zeros(0), np.ones(len(gt_bbox)), np.zeros(0)

    # calculate iou betwen pred_box and gt_box
    overlaps = calculate_iou(pred_bbox, gt_bbox)
    # use Hungarian algorithm to find the matching between gt_boxes and pred_boxes
    row_ind, col_ind = linear_sum_assignment(-overlaps)

    ## Assign TP, FP, FN
    assignment = np.column_stack([row_ind, col_ind])
    tp, fp, fn, pred_iou = np.zeros(len(pred_bbox)), np.ones(len(pred_bbox)), np.ones(len(gt_bbox)), np.zeros(len(pred_bbox))
    for i, j in assignment:
        iou = overlaps[i, j]
        if iou >= iou_thr:
            tp[i] = 1
            fp[i] = 0
            fn[j] = 0
            pred_iou[i] = iou
    
    tp_iou = pred_iou[tp.astype(np.int8) == 1]
    return tp, fp, fn, tp_iou

# %% ../../nbs/metrics/01_det_metrics.ipynb 31
class DetMetrics(torchmetrics.Metric):
    def __init__(self, 
                 iou_thr: float = 0.1, 
                 conf_thr: float = 0.1, 
                 froc_thresholds: Tuple[float, ...] = (0.25, 0.5, 1, 2, 4, 8), 
                 dist_sync_on_step=False):
        super().__init__(dist_sync_on_step=dist_sync_on_step)
        self.iou_thr = iou_thr
        self.conf_thr = conf_thr
        self.froc_thresholds = froc_thresholds
        self.to_np = lambda x: x.detach().cpu().numpy()

        self.add_state("tps", default=[], dist_reduce_fx=None)
        self.add_state("fps", default=[], dist_reduce_fx=None)
        self.add_state("fns", default=[], dist_reduce_fx=None)
        self.add_state("confs", default=[], dist_reduce_fx=None)
        self.add_state("tp_ious", default=[], dist_reduce_fx=None)
        self.add_state("num_images", default=torch.tensor(0.), dist_reduce_fx=None)

    def update(self, pred_bbox, pred_scores, gt_bbox):
        keep = pred_scores >= self.conf_thr
        pred_bbox = pred_bbox[keep]
        pred_scores = pred_scores[keep]

        tp, fp, fn, tp_iou = assign_tp_fp_fn_linear_assignment(self.to_np(pred_bbox), self.to_np(gt_bbox), self.iou_thr)

        self.tps.append(torch.tensor(tp, dtype=torch.float32).to(self.device))
        self.fps.append(torch.tensor(fp, dtype=torch.float32).to(self.device))
        self.fns.append(torch.tensor(fn, dtype=torch.float32).to(self.device))
        self.tp_ious.append(torch.tensor(tp_iou, dtype=torch.float32).to(self.device))
        self.confs.append(torch.tensor(pred_scores, dtype=torch.float32).to(self.device))
        self.num_images += 1

    def compute(self):
        # Ensure there is at least one TP to avoid division by zero

        self.tps = torch.cat(self.tps)
        self.fps = torch.cat(self.fps)
        self.fns = torch.cat(self.fns)
        self.tp_ious = torch.cat(self.tp_ious)
        self.confs = torch.cat(self.confs)
        self.num_images = torch.sum(self.num_images)
      
        metrics = {}
        metrics["conf"] = self.conf_thr
        metrics["iou"] = self.iou_thr
        
        if self.tps == []:
            metrics["fn"] = self.fns.sum().item()
            # Initialize other metrics as well, if needed
            return metrics 

        # Sorting based on confidences
        sorted_indices = torch.argsort(self.confs, descending=True)
        tp_sorted = self.tps[sorted_indices].cpu().numpy()  # Ensure conversion to numpy
        fp_sorted = self.fps[sorted_indices].cpu().numpy()  # Ensure conversion to numpy

        # Cumulative sums for TP and FP to calculate precision and recall
        tp_cumsum = np.cumsum(tp_sorted)
        fp_cumsum = np.cumsum(fp_sorted)

        num_positives = tp_cumsum[-1] + self.fns.sum().item()

        precision = tp_cumsum / (tp_cumsum + fp_cumsum)
        recall = tp_cumsum / num_positives
        fpr = fp_cumsum / self.num_images.item()

        # Interpolation for AP_interp and FROC_interp
        AP_interp = np.interp(np.linspace(0, 1, 11), recall, precision, right=0)
        FROC_interp = np.interp(self.froc_thresholds, fpr, recall, right=0)

        # Update metrics directly with numpy values
        metrics["FROC_thresholds"] = self.froc_thresholds
        metrics["AP_interp"] = AP_interp.tolist()
        metrics["FROC_interp"] = FROC_interp.tolist()
        metrics["FROC"] = FROC_interp.mean()
        metrics["AP"] = AP_interp.mean()
        metrics["recall"] = recall.max()
        metrics["tp"] = tp_cumsum[-1]
        metrics["fp"] = fp_cumsum[-1]
        metrics["avg_tp_iou"] = np.mean(self.tp_ious.cpu().numpy()) if self.tp_ious.numel() > 0 else 0  # Ensure conversion to numpy and handling as numpy array
        metrics["precision"] = precision[-1]
        metrics["fn"] = self.fns.sum().item()

        return metrics