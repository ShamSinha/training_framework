# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/bbox_func/01_bbox_iou.ipynb.

# %% auto 0
__all__ = ['COMPUTE_DTYPE', 'calculate_iou', 'check_2d_3d', 'calculate_iou_numpy', 'intersection_area_pair', 'bbox_area',
           'calculate_iou_pair', 'intersection_area', 'calculate_iou_torch', 'cal_diou_pair', 'cal_diou',
           'cal_giou_pair']

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 3
import torch 
import numpy as np
import fastcore.all as fc

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 5
def _upcast(t: torch.Tensor) -> torch.Tensor:
    # Protects from numerical overflows in multiplications by upcasting to the equivalent higher type
    if t.dtype not in (torch.float32, torch.float64):
        return t.float()
    return t

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 6
def check_2d_3d(shape: int):
    if shape == 6: return 3
    if shape == 4: return 2
    raise NotImplementedError("Only 2D and 3D bboxes are defined")

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 9
def calculate_iou_numpy(pred_bbox: np.ndarray, gt_bbox: np.ndarray):
    """
    Calculate Intersection over Union (IoU) between two sets of bounding boxes using numpy broadcasting.
    :param pred_bbox: numpy array
                      An (Nx4/Nx6) array of predicted bounding boxes in the format [xmin, ymin, xmax, ymax]/[xmin, ymin, zmin, xmax, ymax, zmax]
    :param gt_bbox: numpy array
                      An (Mx4/Mx6) array of ground truth bounding boxes in the format [xmin, ymin, xmax, ymax]/[xmin, ymin, zmin, xmax, ymax, zmax]
    :return iou: numpy array
                      An (NxM) array containing IoU value between each predicted bounding box and ground truth bounding box.
    """
    dim = check_2d_3d(pred_bbox.shape[-1])
    x1 = np.maximum(pred_bbox[:, None, :dim], gt_bbox[:, :dim])
    x2 = np.minimum(pred_bbox[:, None, dim:], gt_bbox[:, dim:])
    inter = np.maximum(0, x2 - x1)
    inter_area = np.prod(inter, axis=-1)
    pred_area = np.prod(pred_bbox[:, -dim:] - pred_bbox[:, :dim], axis=1)
    gt_area = np.prod(gt_bbox[:, -dim:] - gt_bbox[:, :dim], axis=1)
    union = pred_area[:, None] + gt_area - inter_area
    iou = inter_area / union
    return np.clip(iou, 0, 1)

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 21
COMPUTE_DTYPE = torch.float32

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 22
def intersection_area_pair(b1: torch.Tensor, b2: torch.Tensor, dim: int=2):
    x1 = torch.max(b1[:, :dim], b2[:, :dim])
    x2 = torch.min(b1[:, dim:], b2[:, dim:])
    inter_hw = torch.clamp(_upcast(x2 - x1), min=0)
    inter = torch.prod(inter_hw, dim=-1)
    return inter

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 23
def bbox_area(b: torch.Tensor, dim: int=2):
    return torch.prod(_upcast(b[:, dim:] - b[:, :dim]), dim=-1)

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 24
def calculate_iou_pair(b1: torch.Tensor, b2: torch.Tensor):
    """calculate pairwaise iou score. bbox1: N, 4/6, bbox2: N, 4/6"""
    assert b1.shape == b2.shape , "b1 and b2 are of not the same shape"
    dim = check_2d_3d(b1.shape[1])
    inter = intersection_area_pair(b1, b2, dim)
    b1_area, b2_area = bbox_area(b1, dim), bbox_area(b2, dim)
    union = (b1_area + b2_area - inter)
    iou = inter/ (union+torch.finfo(COMPUTE_DTYPE).eps)
    return iou

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 27
def intersection_area(b1: torch.Tensor, b2: torch.Tensor, dim: int=2):
    x1 = torch.max(b1[:, None, :dim], b2[:, :dim])
    x2 = torch.min(b1[:, None, dim:], b2[:, dim:])
    inter = torch.clamp(_upcast(x2 - x1), min=0)
    inter_area = torch.prod(inter, dim=-1)
    return inter_area

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 28
def calculate_iou_torch(b1: torch.Tensor, b2: torch.Tensor):
    """
    Calculate Intersection over Union (IoU) between two sets of bounding boxes using PyTorch broadcasting.
    :param b1: torch tensor
                      A (Nx4/Nx6) tensor of predicted bounding boxes in the format [xmin, ymin, xmax, ymax]/[xmin, ymin, zmin, xmax, ymax, zmax]
    :param b2: torch tensor
                      A (Mx4/Mx6) tensor of ground truth bounding boxes in the format [xmin, ymin, xmax, ymax]/[xmin, ymin, zmin, xmax, ymax, zmax]
    :return iou: torch tensor
                      A (NxM) tensor containing IoU value between each predicted bounding box and ground truth bounding box.
    """
    dim = check_2d_3d(b1.shape[-1])
    inter_area = intersection_area(b1, b2, dim)
    b1_area, b2_area = bbox_area(b1, dim), bbox_area(b2, dim)
    union = b1_area[:, None] + b2_area - inter_area
    iou = inter_area / (union+torch.finfo(COMPUTE_DTYPE).eps)
    return iou.clamp(min=0, max=1)

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 39
calculate_iou = fc.TypeDispatch([calculate_iou_torch, calculate_iou_numpy])

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 44
def cal_diou_pair(b1: torch.Tensor, b2: torch.Tensor):
    """where b1 and b2 have same shape N x 4/6"""
    dim = check_2d_3d(b1.shape[1])
    iou = calculate_iou_pair(b1, b2)
    
    ## center Distance between the bounding boxes
    b1_ctrs = (b1[:,  dim:] + b1[:, :dim])/2
    b2_ctrs = (b2[:,  dim:] + b2[:, :dim])/2
    rho_sq = (_upcast(b1_ctrs - b2_ctrs)**2).sum(1)
    
    ## min-enclosing bbox diagnoal distance. 
    xc = torch.min(b1[:, :dim], b2[:, :dim])
    yc = torch.max(b1[:, dim:], b2[:, dim:])
    diag_sq = (_upcast(yc - xc)**2).sum(1)
    
    diou = iou - (rho_sq/(diag_sq+ torch.finfo(COMPUTE_DTYPE).eps))
    return diou

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 50
def cal_diou(b1: torch.Tensor, b2: torch.Tensor):
    """calculating DIOU between two matrixs"""
    dim = check_2d_3d(b1.shape[1])
    iou = calculate_iou_torch(b1, b2)
    
    ## center Distance between the bounding boxes
    b1_ctrs = (b1[:,  dim:] + b1[:, :dim])/2
    b2_ctrs = (b2[:,  dim:] + b2[:, :dim])/2
    rho_sq = (_upcast(b1_ctrs[:, None, :] - b2_ctrs)**2).sum(2)
    
    ## min-enclosing bbox diagnoal distance. 
    xc = torch.min(b1[:, None,  :dim], b2[:, :dim])
    yc = torch.max(b1[:, None, dim:], b2[:, dim:])
    diag_sq = (_upcast(yc - xc)**2).sum(2)
    
    diou = iou - (rho_sq/(diag_sq+ torch.finfo(COMPUTE_DTYPE).eps))
    return diou

# %% ../../nbs/bbox_func/01_bbox_iou.ipynb 54
def cal_giou_pair(b1: torch.Tensor, b2: torch.Tensor):
    """where b1 and b2 have same shape N x 4/6"""
    dim = check_2d_3d(b1.shape[1])
    inter = intersection_area_pair(b1, b2, dim)
    b1_area, b2_area = bbox_area(b1, dim), bbox_area(b2, dim)
    union = (b1_area + b2_area - inter)
    iou = inter/ (union+torch.finfo(COMPUTE_DTYPE).eps)
    convex_hull_size = torch.max(b1[:, dim:], b2[:, dim:]) - torch.min(b1[:, :dim], b2[:, :dim])
    enc = convex_hull_size.prod(dim=1)
    giou = iou - (1-union/enc)
    return giou
