# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/tfsm/04_med.ipynb.

# %% auto 0
__all__ = ['get_bbox_from_mask', 'resize_factor', 'resample_box', 'AddLungCache', 'CropLung', 'WindowT', 'Resample']

# %% ../../nbs/tfsm/04_med.ipynb 1
import SimpleITK as sitk
import torch
import numpy as np 
import fastcore.all as fc

from pathlib import Path
from typing import Optional
from monai.transforms.spatial.array import Zoom

from .standard import BaseT
from .utils import corner_2_chwd, chwd_2_corner

from qct_utils.apps.lung_segment import LungLobeSeg
from qct_utils.schema.dim import Mask

# %% ../../nbs/tfsm/04_med.ipynb 11
def get_bbox_from_mask(mask: np.ndarray, margin: Optional[tuple] = None):
    """mask is zyx and margin is zyx. output is zyxzyx format"""
    SZ, SY, SX = mask.shape  # zyx
    zz, yy, xx = np.where(mask.astype(bool))
    x1, x2 = np.min(xx) - margin[2], np.max(xx) + margin[2]
    y1, y2 = np.min(yy) - margin[1], np.max(yy) + margin[1]
    z1, z2 = np.min(zz) - margin[0], np.max(zz) + margin[0]
    return np.asarray([max(0, z1), max(0, y1), max(0, x1), min(SZ, z2), min(SY, y2), min(SX, x2)])

# %% ../../nbs/tfsm/04_med.ipynb 28
def resize_factor(img_shape: tuple, spacing: tuple, new_spacing: tuple):
    """bbox=zyxzyx, img_shape=zyx spacing=zyx new_spacing=zyx"""
    new_shape = np.round(np.asarray(img_shape) * np.asarray(spacing)/ np.asarray(new_spacing))
    rf = new_shape / np.asarray(img_shape)
    return rf

# %% ../../nbs/tfsm/04_med.ipynb 29
def resample_box(bbox, img_shape: tuple, spacing: tuple, new_spacing: tuple):
    """bbox=zyxzyx, img_shape=zyx spacing=zyx new_spacing=zyx"""
    nbbox = bbox.copy()
    rf = resize_factor(img_shape, spacing, new_spacing)
    resample = rf.reshape(-1, 1).repeat(2, 1).T.reshape(-1)
    nbbox = nbbox*resample
    return nbbox

# %% ../../nbs/tfsm/04_med.ipynb 32
class AddLungCache(BaseT):
    def __init__(self, cache_dir: Optional[str]=None, device: str="cuda"):
        super().__init__()
        fc.store_attr()
        self.margin = (2, 5, 5)
        from qct_utils.apps.lung_segment import LungLobeSeg
        self.lsd = LungLobeSeg(checkpoint_path= "/home/users/shubham.kumar/projects/qct_utils/src/qct_utils/apps/lung_segment/v2/resources/epoch=263_step=705_val_dice=0.95.ckpt" ,device=self.device)
    __repr__ = fc.basic_repr(flds="cache_dir")
    
    def apply(self, img:dict):
        if "series_id" not in img.keys(): return img 
        if self.cache_dir is not None:
            lung_mask_path = Path(self.cache_dir)/(img["series_id"]+"_lung_mask.npy")
        else:
            img["lung_mask"] , _ = self.lsd.predict_lung_lobe(img["images"])
            return img 
        if not lung_mask_path.exists(): 
            img["lung_mask"] , _ = self.lsd.predict_lung_lobe(img["images"])
            np.save(lung_mask_path, img["lung_mask"])
            return img 
        img["lung_mask"] = np.load(lung_mask_path)
        return img 
    
    def reverse_apply(self, img: dict): return img

# %% ../../nbs/tfsm/04_med.ipynb 57
class CropLung(BaseT):
    def __init__(self, 
                 margin: tuple=(2, 5, 5), 
                 device: str="cuda",
                 roi: Optional[str] = None,
                ):
        """ tuple in zyx format, roi could be "left" , right or None. Use AddLungCache if required."""
        super().__init__()
        fc.store_attr()
        from qct_utils.apps.lung_segment import LungLobeSeg
        self.lsd = LungLobeSeg(checkpoint_path="/home/users/shubham.kumar/projects/qct_utils/src/qct_utils/apps/lung_segment/v2/resources/epoch=263_step=705_val_dice=0.95.ckpt", device=self.device)
    
    __repr__ = fc.basic_repr(flds="margin")
        
    
    def apply(self, img:dict):
        from loguru import logger
        assert "images" in img.keys(), f"images are present in input {img.keys()}"
        series_id = img["series_id"] if isinstance(img["series_id"], str) else img["series_id"][0]
        fimg = img["images"].copy()
        img_shape = fimg.shape if len(fimg.shape) == 3 else fimg.shape[1:]
        nimg = {}
        if "lung_mask" in img.keys():
            nimg["lung_mask"] = img["lung_mask"]
        else:
            nimg["lung_mask"], _ = self.lsd.predict_lung_lobe(fimg)
            
        if self.roi == "left" : 
            left_lung_mask = nimg["lung_mask"].copy()
            left_lung_mask[left_lung_mask == 1] = 0
            left_lung_mask[left_lung_mask == 2] = 1
            nimg["lung_mask"] = left_lung_mask
            
        if self.roi == "right" : 
            right_lung_mask = nimg["lung_mask"].copy()
            right_lung_mask[right_lung_mask == 2] = 0
            nimg["lung_mask"] = right_lung_mask
            
        nimg["lung_box"] = get_bbox_from_mask(nimg["lung_mask"],self.margin)
        nimg["images"] = self.apply_image(fimg, nimg["lung_box"])
        
        if "boxes" in img : 
            nimg["boxes"] = self.apply_bbox(img["boxes"], nimg["lung_box"])
                     
        for i in img.keys(): 
            if i not in nimg.keys(): nimg[i] = img[i]
        return nimg
        
    def apply_image(self, img: np.asarray, b: np.asarray):
        out = img.copy()
        #bboxes are zyxzyx format and image is zyx
        out = out[b[0]: b[3], b[1]: b[4], b[2]: b[5]]
        return out
    
    def apply_bbox(self, bbox, lung_box):
        # bbox is zyxzyx where as lung box is zyxzyx
        from voxdet.tfsm.voxt import crop_bbox
        fb = lung_box  
        img_size = [fb[3]-fb[0], fb[4]-fb[1], fb[5]-fb[2]]
        out = crop_bbox(bbox.copy(), fb, img_size, keep_volume=0)
        return out
    
    def reverse_apply_bbox(self, bbox, lung_box):
        """lung mask is of original scan shope, bbox and lung_box can be or cannot be """
        out = bbox.copy()
        out = corner_2_chwd(bbox)
        out[:, 0] += lung_box[0]
        out[:, 1] += lung_box[1]
        out[:, 2] += lung_box[2]
        out = chwd_2_corner(out)
        return out
    
    def reverse_apply(self, img: dict):
        assert "lung_box" in img.keys(), f"lung_box not in {img.keys()}"
        nimg = {}
        nimg["boxes"] = self.reverse_apply_bbox(img["boxes"], img["lung_box"])
        for i in img.keys(): 
            if i not in nimg.keys(): nimg[i] = img[i]
        return nimg        

# %% ../../nbs/tfsm/04_med.ipynb 70
class WindowT(BaseT):
    def __init__(self, wt: str=None, ww: int=None, wl: float=None):
        """window_type, window_width, window_level"""
        super().__init__()
        fc.store_attr()
        if all([i is None for i in [self.wt, self.ww, self.wl]]): raise ValueError("Everything cannot be none")    
        if self.wt is None: 
            assert all([i is not None for i in [self.ww, self.wl]]), ValueError("ww and wl cannot be None when wt is none")
        
        self.windows = self._default_windows()
        
        if (self.wt is not None) & (self.wt in list(self.windows)): 
                level = self.windows[self.wt]
                self.ww, self.wl= level
        
        if (self.wt is not None) & (self.wt not in list(self.windows)):
            assert all([i is not None for i in [self.ww, self.wl]]), ValueError(f"wt:{self.wt} is not available in {list(self.windows)} and ww, wl is None")
        
        self.low = self.wl - self.ww/2
        self.high = self.wl + self.ww/2
    
    __repr__ = fc.basic_repr(flds="wt, ww, wl")
    
    def _default_windows(self):
        k = {}
        k["lung"] = (1600, -600)
        k["soft_tissue"] = (350, 40)
        return k
    
    def apply(self, img: dict):
        assert "images" in img.keys(), "images key is not present"
        fimg = img["images"]
        nimg = {}
        nimg["images"] = self.apply_image(fimg)
        for i in img.keys(): 
            if i not in nimg.keys(): nimg[i] = img[i]
        return nimg 
    
    def apply_image(self, img):
        out = img.copy()
        out = (out-self.low)/(self.high-self.low)
        out = np.clip(out, 0, 1)
        return out.astype(np.float32)
    
    def reverse_apply(self, img): return img 

# %% ../../nbs/tfsm/04_med.ipynb 81
class Resample(BaseT):
    def __init__(self, req_spacing: tuple=(1.0, 1.0, 1.0)):
        """req_spacing is in zyx format"""
        fc.store_attr()
        super().__init__()
    __repr__ = fc.basic_repr(flds="req_spacing")
    
    def apply(self, img: dict):
        assert all([i in list(img.keys()) for i in ["images", "spacing"]])
        fimg, spacing = img["images"], img["spacing"]
        img_shape = img["images"].shape if len(img["images"].shape) == 3 else img["images"].shape[1:]
        nimg = {}
        nimg["images"] = self.apply_image(fimg, spacing)
        if "boxes" in img.keys(): nimg["boxes"] = self.apply_bbox(img["boxes"], img_shape, spacing)
        for i in img.keys(): 
            if i not in nimg.keys(): nimg[i] = img[i]
        return nimg
    
    def apply_image(self, img, spacing):
        out = img.copy()
        rf = resize_factor(out.shape, spacing, self.req_spacing)
        rimg = Zoom(zoom=rf.tolist(), keep_size=False)(out[None])[0].numpy()
        return rimg.astype(np.float64)
        
    def apply_bbox(self, bbox, img_shape, spacing):
        out = bbox.copy().astype(np.float64)
        return resample_box(out, img_shape, spacing, self.req_spacing)
    
    def reverse_apply(self, img: dict):
        assert "boxes" in img.keys()
        out = img["boxes"].copy()
        img_shape = img["images"].shape if len(img["images"].shape) == 3 else img["images"].shape[1:]
        img["boxes"] = resample_box(out, img_shape, self.req_spacing, img["spacing"])
        return img
